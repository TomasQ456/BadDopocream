# Bad Dopo-Cream

Bad Dopo-Cream is a three-layer (domain, memory, presentation) Java 17 implementation that recreates the classic ice arena battles with an explicit event system and AI-driven opponents.

## ¿Qué se ha completado?
- Arquitectura completa dividida en dominio, memoria y presentación con sistema de eventos y enemigos IA.
- Documentación Javadoc exhaustiva sobre entidades, repositorios, interfaces y pruebas automatizadas.
- Sustitución total de Maven por un flujo ligero basado únicamente en herramientas del JDK.
- Creación de un parser JSON propio (`SimpleJsonParser`) y persistencia sin dependencias externas en `FileLevelRepository`.
- Implementación de un mini-runner que emula JUnit 5 (`org.junit.jupiter` shim + `test.runner.TestRunner`).

## Project Layout
- `src/domain`: Core simulation entities, movement, path-finding, and domain events.
- `src/memory`: Persistence concerns, including the dependency-free `FileLevelRepository` and JSON parser.
- `src/presentation`: UI bridge, renderer contract, and input models.
- `src/test`: Specification-style tests covering every layer.
- `src/test/runner`: Reflection-based runner that replaces Maven/Surefire.

## Building Without Maven
The project deliberately avoids Maven/Gradle. Use the stock JDK tools (commands shown for PowerShell):

```powershell
# 1) Clean and compile everything into ./bin
Remove-Item -Recurse -Force bin -ErrorAction SilentlyContinue
New-Item -ItemType Directory bin | Out-Null
$source = Get-ChildItem -Path src -Recurse -Include *.java | ForEach-Object { $_.FullName }
javac -d bin $source

# 2) Run the (currently stub) entry point
java -cp bin App
```

## Running the Tests
Maven-based testing has been removed. Execute the embedded runner, which understands the custom `org.junit.jupiter` shim:

```powershell
java -cp bin test.runner.TestRunner
```

The runner prints per-test pass/fail information and exits non-zero on failure so it can be scripted in CI or VS Code tasks.

## Level File Format
`FileLevelRepository` expects JSON descriptors located in the configured levels folder. A minimal `level-1.json` looks like this:

```json
{
	"id": 1,
	"width": 5,
	"height": 5,
	"player": { "x": 1, "y": 1 },
	"statics": [
		{ "type": "indestructible", "position": { "x": 0, "y": 0 } }
	],
	"fruits": [
		{ "type": "CHERRY", "points": 100, "position": { "x": 2, "y": 2 } }
	],
	"enemies": [
		{
			"type": "TROLL",
			"spawn": { "x": 3, "y": 3 },
			"path": ["LEFT", "UP"]
		}
	]
}
```

Save files (`save-game.json`) share the schema generated by `GameStateRecord`:

```json
{
	"levelId": 1,
	"score": 900,
	"playerPosition": { "x": 2, "y": 3 }
}
```

Both documents are parsed using the built-in `SimpleJsonParser`, so no external libraries are required.
